// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

using Microsoft.Extensions.Configuration;
using Microsoft365.DeveloperProxy.Abstractions;
using System.Net;
using System.Text.Json;
using System.Text.RegularExpressions;
using Titanium.Web.Proxy.Http;
using Titanium.Web.Proxy.Models;

namespace Microsoft365.DeveloperProxy.Plugins.Behavior;

public class RetryAfterPlugin : BaseProxyPlugin
{
  public override string Name => nameof(RetryAfterPlugin);

  public override void Register(IPluginEvents pluginEvents,
                       IProxyContext context,
                       ISet<UrlToWatch> urlsToWatch,
                       IConfigurationSection? configSection = null)
  {
    base.Register(pluginEvents, context, urlsToWatch, configSection);

    pluginEvents.BeforeRequest += OnRequest;
  }

  private async Task OnRequest(object? sender, ProxyRequestArgs e)
  {
    if (e.ResponseState.HasBeenSet ||
        _urlsToWatch is null ||
        !e.ShouldExecute(_urlsToWatch))
    {
      return;
    }

    ThrottleIfNecessary(e);
  }

  private void ThrottleIfNecessary(ProxyRequestArgs e)
  {
    var request = e.Session.HttpClient.Request;
    var expiredThrottlers = e.ThrottledRequests.Where(t => t.ResetTime < DateTime.Now);
    foreach (var throttler in expiredThrottlers)
    {
      e.ThrottledRequests.Remove(throttler);
    }

    if (!e.ThrottledRequests.Any())
    {
      return;
    }

    foreach (var throttler in e.ThrottledRequests)
    {
      var throttleInfo = throttler.ShouldThrottle(request, throttler.ThrottlingKey);
      if (throttleInfo.ThrottleForSeconds > 0)
      {
        _logger?.LogRequest(new[] { $"Calling {request.Url} before waiting for the Retry-After period.", "Request will be throttled", $"Throttling on {throttler.ThrottlingKey}" }, MessageType.Failed, new LoggingContext(e.Session));

        throttler.ResetTime = DateTime.Now.AddSeconds(throttleInfo.ThrottleForSeconds);
        UpdateProxyResponse(e, throttleInfo);
        break;
      }
    }
  }

  private void UpdateProxyResponse(ProxyRequestArgs e, ThrottlingInfo throttlingInfo)
  {
    var headers = new List<HttpHeader>();
    var body = string.Empty;
    var request = e.Session.HttpClient.Request;

    // override the response body and headers for the error response
    if (ProxyUtils.IsGraphRequest(request))
    {
      string requestId = Guid.NewGuid().ToString();
      string requestDate = DateTime.Now.ToString();
      headers.AddRange(ProxyUtils.BuildGraphResponseHeaders(request, requestId, requestDate));

      body = JsonSerializer.Serialize(new GraphErrorResponseBody(
          new GraphErrorResponseError
          {
            Code = new Regex("([A-Z])").Replace(HttpStatusCode.TooManyRequests.ToString(), m => { return $" {m.Groups[1]}"; }).Trim(),
            Message = BuildApiErrorMessage(request),
            InnerError = new GraphErrorResponseInnerError
            {
              RequestId = requestId,
              Date = requestDate
            }
          })
      );
    }

    headers.Add(new HttpHeader(throttlingInfo.RetryAfterHeaderName, throttlingInfo.ThrottleForSeconds.ToString()));

    e.Session.GenericResponse(body ?? string.Empty, HttpStatusCode.TooManyRequests, headers);
    e.ResponseState.HasBeenSet = true;
  }

  private static string BuildApiErrorMessage(Request r) => $"Some error was generated by the proxy. {(ProxyUtils.IsGraphRequest(r) ? ProxyUtils.IsSdkRequest(r) ? "" : String.Join(' ', MessageUtils.BuildUseSdkForErrorsMessage(r)) : "")}";
}
